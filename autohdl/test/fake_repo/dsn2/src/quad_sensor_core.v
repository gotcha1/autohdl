//**********Модуль обработки квадратунрного датчки скорости и положения*****************************//
//Назначение: иодуль обработки квадратунрного датчки скорости и положения предназначенный для совместной работы с модулем
//обработки СКВТ resolver_kalman. ВНИМАНИЕ! Есть ограничение по скорости. Если между метками менее 2048 тактов скорость не вычисляется.
//Входы:
//rst	    - асинхронный сброс
//clk	    - тактовый генератор		  
//cA       - Вход по каналу A
//cB       - Вход по каналу B
//cC       - Вход по каналу C (нуль-метка)
//
//Выходы:
//phi       - положение, знаковое 32 бит. Коэфициент преобразования рад/код = pi/2^15
//omega     - скорость, знаковая 31 бит.
//to		- Значение времени между двумя фронтами в тактах(30 бит, беззнаковое)
//phi_rdy   - Флаг обновления положения
//omega_rdy - Флаг обновления скорости
//sync_rst  - cинхронный сброс СКВТ
//																
//Запаздывание связанное с расчетом составляет 1 такт для положения (20 нс при clk 50 МГц)
//Запаздывание связанное с расчетом составляет 32 такта для скорости (640 нс при clk 50 МГц)
//
//Автор: Романов А.М.
//		 Кафедра "Проблем управления" МИРЭА(ТУ), 2009 г.
//**************************************************************************************************//
module quad_sensor_core(rst,clk,cA,cB,cC,phi,omega,phi_rdy,omega_rdy,sync_rst,to,out,acc_level);
	input  rst;  			//Асинхронный сброс
	input  clk;  			//Тактовый генератор
	input  cA;				//Вход по каналу A
	input  cB;				//Вход по каналу B
	input  cC;				//Вход по каналу C (нуль метка)
	output reg[31:0]phi;	//Положение из расчета pi[рад] = 2^15. (32 бита, знаковое)
	output reg[30:0]omega;	//Скорость из расчета  (31 бит, знаковое)
	output reg[29:0]to;		//Значение времени между двумя фронтами в тактах(30 бит, беззнаковое)	  
	input  [15:0]acc_level;
	output reg[15:0]out;	
	
	output reg phi_rdy;		//Значение положения обновилось
	output reg omega_rdy;	//Значение скорости обновилось			 					 
	output reg sync_rst;	//Синхронный сброс СКВТ по факту прихода 0 метки
	
parameter ZeroPHI=32'h0;	
parameter ZeroSpeedN = 24;  //Номер бита выше которого скорость не накапливается. Т.е мы принимаем, что если не было меток в течении 2^25 тактов, то скорость равна 0

reg p_A; 	//Предыдущее значение канала A
reg p_B;	//Предыдущее значение канала B
reg p_C;	//Предыдущее значение канала C	 	 
reg dir;	//Направление 1 - отрицательное, 0 - положительное
reg [30:0]omegaTimer; //Таймер для расчета скорости методом заполнения
reg WasOverflow;		 
 		 

reg  start;
reg  [29:0]t;
wire [29:0]spd;		  

reg  tmp_dir;	//Направление на момент начала вычисления скорости

reg [30:0]nomega;

always @(*)
	if(tmp_dir)
		nomega<={tmp_dir,-spd};
	else 
		nomega<={tmp_dir,spd};	

wire [31:0]domega;
wire [30:0]abs_domega;

assign domega = {nomega[30],nomega}-{omega[30],omega};
assign abs_domega = domega[31] ? - domega : domega;

wire rdy;

parameter NO_SPEED_LIMIT = 1;  //если 1, то нет ограничения скорости

cordic_inv_t_core inv_t (.rst(rst),
						 .clk(clk),
						 .start(start),
						 .t(t),
						 .spd(spd),
						 .rdy(rdy)
);

reg ch_on_boot;			   

reg chA; 	//Значение канала A
reg chB;	//Значение канала B
reg chC;	//Значение канала C	 	 	   




always @(posedge rst or posedge clk)
	if (rst)
		begin
			chA <= 0;
			chB <= 0;
			chC <= 0;
		end	else
		begin
			chA <= cA;
			chB <= cB;
			chC <= cC;
		end	

always @(posedge rst or posedge clk)
	if(rst)
		begin
			ch_on_boot<=1'b1;
			p_A<=1'b0;
			p_B<=1'b0;
			p_C<=1'b0;						
			omega<=16'd0;	 
			phi<=32'd0;	
			phi_rdy<=1'b0;
			start<=1'b0;
			omega_rdy<=1'b0;
			omegaTimer<=31'd1; //Ставим таймер в 1, т.к. на этом такте он уже не увиличится, а на следующем уже пройдет 1 такт
			dir<=1'b0;
			WasOverflow<=1'b0;
			t<=30'd0;	  
			sync_rst<=1'b0;		
			to <=0;
			tmp_dir <= 0;	 
			out<=0;
		end	else
		begin	 
			if (ch_on_boot)
				begin
					ch_on_boot<=1'b0;
					p_A<=chA;
					p_B<=chB;
					p_C<=chC;						
				end			 
			else	
			if ((p_A!=chA)/*||(p_B!=chB)*/)
				begin
					omegaTimer<=31'd1;	//Ставим таймер в 1, т.к. на этом такте он уже не увиличится, а на следующем уже пройдет 1 такт
					if (WasOverflow)
						begin																  
							WasOverflow<=1'b0;//Снимаем флаг переполнения
							omega<=16'd0;     //Если было хотя бы одно переполнение таймера, то скорость равна 0
							omega_rdy<=1'b1;  //Выставляем флаг, того что скорость обновлена  
						end	else		 
						begin			 
							if(t[29:12]|(NO_SPEED_LIMIT))	  		  //Если t менее 2048, то считаем, что скорость нереально быстрая
								begin 
									start<=1'b1;	  	  //Иначе начинаем расчет скорости как 1/omegaTimer*2^30															
									tmp_dir <= dir;
								end	
							to <= omegaTimer[29:0]; //Сохраняем предыдущее значение таймера, чтоб его мог скушать inv_t_core
                			t<=omegaTimer[29:0]; //Сохраняем предыдущее значение таймера, чтоб его мог скушать inv_t_core
						end	
				end		
			if ((p_C!=chC))
			begin 		  
				if(chC^dir)
					begin 
						phi<=ZeroPHI;	    //Если сработала 0 метка, то выставляем полжение, в том место где она сработала
						phi_rdy<=1'b1;	 	//Выставляем флаг обновления положения										   
						sync_rst<=1'b1;
					end
				p_C<=chC;
			end else	
			begin
				sync_rst<=1'b0;
				if (p_A!=chA)			//Если фронт канала А
					begin	  
						if (chA^chB)
						begin											 
							//************************Отрицательное направление*******************
							phi[31:14]<=phi[31:14]-1;
							phi_rdy<=1'b1;	 	//Выставляем флаг обновления положения
							dir<=1'b1;			//Выставляем бит направления
							//************************Отрицательное направление*******************
						end	else
						begin					
							//************************Положительное направление*******************
							phi[31:14]<=phi[31:14]+1;
							phi_rdy<=1'b1;	 	//Выставляем флаг обновления положения
							dir<=1'b0;			//Выставляем бит направления
							//************************Положительное направление*******************
						end		
						p_A<=chA;   //Сохраняем значение канала A
					end
				else		
				if (p_B!=chB)
						begin 
							if (chA^chB)
							begin
								//************************Положительное направление*******************
								phi[31:14]<=phi[31:14]+1;
								phi_rdy<=1'b1;	 	//Выставляем флаг обновления положения
								dir<=1'b0;			//Выставляем бит направления
								//************************Положительное направление*******************
							end	else
							begin					
								//************************Отрицательное направление*******************
								phi[31:14]<=phi[31:14]-1;	
								phi_rdy<=1'b1;	 	//Выставляем флаг обновления положения
								dir<=1'b1;			//Выставляем бит направления
								//************************Отрицательное направление*******************
							end					
							p_B<=chB;	//Сохраняем значение канала B
						end	 else 
						begin			
							to <= {WasOverflow,13'b0,omegaTimer[30:15]}; //Сохраняем предыдущее значение таймера, чтоб его мог скушать inv_t_core
							phi_rdy<=1'b0;    		//Если нет фронта сбрасываем сигнал phy_rdy
							if(omegaTimer[ZeroSpeedN])		//Если таймер превысил 30 бит, то фиксируем переполнение, дальнейшая судьба таймера нас уже не интересует
								WasOverflow<=1'b1;
                            else
    							omegaTimer<=omegaTimer+31'd1; //Если не было фронта, то автоинкрементируем таймер
						end																					 
			end		
			if (WasOverflow)
				begin 
					omega<=16'd0;     //Если было хотя бы одно переполнение таймера, то скорость равна 0
					omega_rdy<=1'b1;  //Выставляем флаг, того что скорость обновлена  
				end else
			if (rdy)
				begin					
					if ((abs_domega>{acc_level,4'b0})&(~NO_SPEED_LIMIT))
							out <= out+1;
					else			 
						begin
							omega <= nomega;
							omega_rdy<=1'b1; //Если пришел флаг, того, что модуль скорости посчитался, то выводим ее с учетом направления и выставляем флаг обновления значения скорости
						end
				end else
					if (omega_rdy) omega_rdy<=1'b0; //Если флаг rdy не пришел, а omega_rdy - выставлен, то снимаем его
			if (start) start<=1'b0; //Делаем, так чтоб старт более одного такта не держался
		end						 
endmodule
