//************************************Модуль расчета цифрового ПИ-регулятора***********************************************
//На каждый строб старта происходит расчет нового значение выхода для цифрового ПИ регулятора:
// u ---------------Kp--------O----- y
//      |  					  |
//		|---Ki--O-------------|
//				|	     |
//				|-(z^-1)-|
//
//Коэффициенты Kp и Ki не должны изменяться после поднятия строба start и до прихода флага rdy
//Строб синхронного сброса аккамулятора не должен выставляться во время расчета (т.е. в период после поднятия строба start 
//и до прихода флага rdy
//
//Входы:
//  rst				 - Асинхронный сброс
//  clk				 - Тактовый генератор
//	start			 - Cтроб начала вычислений одной итерации
//	e				 - Входное значени рассогласования (19 бит, целое, знаковое)
//	Kp				 - Коэффициент пропрорционального звена (19 бит, k бит целой части, 18-k бит дробной части, знаковое)
//	Ki				 - Коэффициент интегрального звена (19 бит, k бит целой части, 18-k бит дробной части, знаковое)
//  int_rst			 - Синхронный сброс аккамулятора
//	c				 - Вход c умножителя mult19 (37 бит, целое, знаковое)
//  mul_rdy          - Флаг готовности умножителя
//
//Выходы:
//	u				 - Выходное значение регулятора (19 бит, целое, знаковое)
//	rdy				 - Флаг окончания вычислений
//	a				 - Выход на умножитель mult19 (19 бит, целое, знаковое)
//	b				 - Выход на умножитель mult19 (19 бит, целое, знаковое)
//	mul_busy		 - Флаг того, что умножитель mult19 занят
//  mul_start        - Cтроб запуска умножителя
//
//Параметры:
//	k				 - Кол-во бит целой части коэффициентов регулятора	 (0..18) ПОМНИМ, что один из них - знак!
//
//Время расчета регулятора 3 такта (60 нс на 50 МГц тактовом генераторе)
//
//Автор: Романов А.М.
//		 Кафедра "Проблем управления" МИРЭА(ТУ) 2009 г.
//*************************************************************************************************************************

module PI_Regulator(
	input  rst,					//Асинхронный сброс
	input  clk,					//Тактовый генератор
	input  start,				//Cтроб начала вычислений одной итерации
	input  [18:0]e,				//Входное значени рассогласования (19 бит, целое, знаковое)
	input  [18:0]Kp,			//Коэффициент пропрорционального звена (19 бит, k бит целой части, 18-k бит дробной части, знаковое)
	input  [18:0]Ki,			//Коэффициент интегрального звена (19 бит, k бит целой части, 18-k бит дробной части, знаковое)
	output reg [18:0]u,			//Выходное значение регулятора (19 бит, целое, знаковое)
	output reg rdy,				//Флаг окончания вычислений
	input  int_rst,				//Синхронный сброс интегратора
	output [18:0]a,				//Выход на умножитель mult19 (19 бит, целое, знаковое)
	output reg  [18:0]b,		//Выход на умножитель mult19 (19 бит, целое, знаковое)
	output mul_busy,			//Флаг того, что умножитель mult19 занят
    output reg mul_start,       //Строб запуска умножителя
    input mul_rdy,              //Флаг готовности умножителя
	input  [36:0]c,				//Вход c умножителя mult19 (37 бит, целое, знаковое)
	output [15:0]acc_out
	);

parameter k=0;					//Кол-во бит целой части коэффициентов регулятора	 (0..18)
	
wire [k:0] allones;				
wire [k:0] allzeroes;

assign allzeroes = 0;
assign allones = ~0;
	
	
//typedef enum logic[2:0] {
parameter
	st_idle			= 3'b001,
	st_ki	        = 3'b010,
	st_kp           = 3'b100
	;//} IPState;					 
	
	reg [2:0] /*IPState*/ state;	//Регистр состояния   		 
	
assign mul_busy = (state!=st_idle);

reg [36:0]acc;								//Интегратор
wire [37:0]summ;  									   

assign acc_out = acc[36:21];

assign summ   = {acc[36],acc} + {c[36],c};  //Сумматор значения интегратора с результатом умножения

reg [18:0]e0; //Значение на входе регулятора сохраненное на момент вычислений

assign a = e0; //На первый вход умножителя подаем значение ошибки

reg [1:0]OutWindUp;  //флаг того, что выход уперся в упор (т.е. интегратор больше не интегрируем)
//2'b00 или 2'b10 - нет wind up
//2'b11 - wind up в минус
//2'b01 - wind up в плюс
	
always @(posedge rst or posedge clk)
	if(rst)
		begin
			acc <=0;
			state <= st_idle;
			rdy <= 0;
			b <= 0;				
			u <= 0;
			e0 <=0;
            mul_start <= 0;
            OutWindUp <= 2'b00;
		end	else
		begin
			case (state)
				st_idle:
					begin		 
						if(start)
							begin			   
								e0 <= e;		   //Сохраняем значение e на время расчета регулятора
								b <= Ki;		   //Умножаем e*Ki
                                mul_start <= 1;    //Запускаем умножитель
								state <= st_ki;
							end
						rdy <= 0;				   //Снимаем флаг готовности
					end		   
				st_ki:
					begin
                        if(mul_rdy)
                            begin
						        if(summ[37])						 //Ограничиваем сумму старого значение интегратора с e*Ki до 37 бит (знаковое) 
							        begin  							 //и присваеваем ее интегратору
								        if (summ[36])
                                            begin
                                                if(OutWindUp!=2'b11) //если нет переполнения выхода в отрицательную сторону
        									        acc <= summ[36:0];
                                            end else
                                            begin
                                                if(OutWindUp!=2'b11) //если нет переполнения выхода в отрицательную сторону
          									        acc <= 37'h1000000000;
                                            end
							        end else		   
								        begin					 
									        if(summ[36])
                                                begin
                                                    if(OutWindUp!=2'b01) //если нет переполнения выхода в положительную сторону
        										        acc <= 37'h0FFFFFFFFF;
                                                end else
                                                begin
                                                    if(OutWindUp!=2'b01) //если нет переполнения выхода в положительную сторону
        										        acc <= summ[36:0];
                                                end
								        end							
						        b <= Kp; 						   	//Умножаем e*Kp
                                mul_start <= 1;    //Запускаем умножитель
						        state <= st_kp;
                           end else
                                mul_start <= 0;
					end
				st_kp:
					begin
                        if(mul_rdy)
                            begin
						        if (summ[37])			//Ограничиваем результат сложнения интегратора с e*Kp до 19 бит (знаковое)
							        begin
								        if (summ[36:36-k]==allones)  	    
                                        begin
    									    u <= summ[36-k:18-k];
                                            OutWindUp <= 2'b00; //нет переполнения выхода
                                        end else 
                                             begin
									            u <= 19'h40000;	
                                                OutWindUp <= 2'b11; //переполнение в отрицательную сторону
                                             end
							        end else
								        begin
									        if (summ[36:36-k]==allzeroes)  
                                            begin
										        u <= summ[36-k:18-k]; //нет переполнения выхода
                                                OutWindUp <= 2'b00;
                                            end else
                                                begin
										            u <= 19'h3FFFF;	
                                                    OutWindUp <= 2'b01;
                                                end
								        end	
						        rdy <= 1;			   //Выставляем флаг готовности
                                mul_start <= 0;
						        state <= st_idle;
                            end else
                                mul_start <= 0;
					end
			endcase	
			if(int_rst)				   //Если выставлен синхронный сброс - сбрасываем интегратор в 0
				acc <= 0;	
		end
endmodule	
			   
